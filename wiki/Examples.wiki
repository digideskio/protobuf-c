#summary A set of easy examples, in lieu of documentation

= Introduction =

Examples of using protobuf-c.

protobuf-c works by taking a .proto file (which is defined by google's Protocol Buffers library), and generating .h and .c files you can use from C.

Warning (insert guy shoveling pic):  this page is partial, incomplete and the code is untested.  Eventually I plan to make an "examples" directory in the .tar.gz so you don't need to cut-n-paste. 

= Simple complete example =


Here is a simple file, `amessage.proto` file:
{{{
   message AMessage
   {
      required int a;
      optional int b;
   }
}}}

You can generate .h and .c files from the command-line:
{{{
   protoc-c --output_dir=. FIXME
}}}

You might write a program to pack a message:
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    AMessage msg = A_MESSAGE__INIT;  
   void *buf;
   unsigned len;
   if (argc < 2 || argc > 3)
     {
        fprintf(stderr,"usage: pack a [b]\n");
        return 1;
     }
    msg.a = atoi (argv[1]);
    if (argc == 3) { msg.has_b = 1; msg.b = atoi(argv[2]); }
    len = a_message__get_packed_size (&msg);
    buf = malloc (len);
    a_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    return 0;
  } 
}}}
I left most error handling out for brevity.  Notice:
  * the use of the A_MESSAGE__INIT macro to construct the message
  * the "has_b" member that corresponds to the optional `b` field -- required fields do not have a has_ member.
  * a_message__get_packed_size returns the length of the packed data.
  * a_message__pack serializes the message.

On the other hand, if you want to deserialize/unpack a message,
you could use code like this:
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  #define MAX_MESSAGE_SIZE  4096
  int main(int argc, char **argv)
  {
    AMessage *msg;
    char buf[MAX_MESSAGE_SIZE];
    while ((c=fgetc(stdin)) != EOF)
      {
	if (buf_size == MAX_MESSAGE_SIZE)
	  {
	    fprintf(stderr, "message too long for this program\n");
	    return 1;
	  }
	buf[buf_size++] = c;
      }
    msg = a_message__unpack (NULL, buf_size, buf);
    if (msg == NULL)
      {
	fprintf(stderr, "error unpacking message\n");
	return 1;
      }
    printf ("a=%d", msg->a);
    if (msg->has_b)
      printf ("; b=%d", msg->b);
    printf ("\n");
    return 0;
  } 
}}}

= Repeated Fields =
Here is a simple file, `cmessage.proto` file:
{{{
   message CMessage
   {
      repeated int c;
   }
}}}

You might write a program to pack a message:
{{{
  #include "cmessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    CMessage msg = C_MESSAGE__INIT;  
   void *buf;
   unsigned len;
   msg.n_c = argc - 1;
   msg.c = malloc (sizeof (int) * msg.n_c);
   for (i = 0; i < msg.n_c; i++)
     msg.c[i] = atoi (argv[i+1]);
    len = c_message__get_packed_size (&msg);
    buf = malloc (len);
    c_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    free (msg.c);
    free (buf);
    return 0;
  } 
}}}
I left most error handling out for brevity.  Notice:
  * the use of the C_MESSAGE__INIT macro to construct the message
  * we allocate buf and msg.c, so we must free them.
  * the n_XXX member is generated for a repeated field XXX.

On the other hand, if you want to deserialize/unpack a message,
you could use code like this:
{{{
  #include "cmessage.pb-c.h"
  #include <stdio.h>
  #define MAX_MESSAGE_SIZE  4096
  int main(int argc, char **argv)
  {
    AMessage *msg;
    char buf[MAX_MESSAGE_SIZE];
    while ((c=fgetc(stdin)) != EOF)
      {
	if (buf_size == MAX_MESSAGE_SIZE)
	  {
	    fprintf(stderr, "message too long for this program\n");
	    return 1;
	  }
	buf[buf_size++] = c;
      }
    msg = c_message__unpack (NULL, buf_size, buf);
    if (msg == NULL)
      {
	fprintf(stderr, "error unpacking message\n");
	return 1;
      }
    for (i = 0; i < msg->n_c; i++)
      {
        if (i > 0)
	  printf (", ");
	printf ("%d", msg->c[i]);
      }
    printf ("\n");
    return 0;
  } 
}}}

= Strings =

= Bytes =


= Constructing Submessages =
Here is a simple file, `dmessage.proto` file:
{{{
   message Submessage
   {
      required int value;
   };
   message DMessage
   {
      required Submessage d;
      optional Submessage e;
   }
}}}

Here is a simple program to pack a message of type `DMessage`.
Note that `DMessage` consists of one or two integers (`d` is required and has one int; `e` is optional and has one int).
  
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    DMessage msg = D_MESSAGE__INIT;  
    Submessage sub1 = SUBMESSAGE__INIT;
    Submessage sub2 = SUBMESSAGE__INIT;
    void *buf;
    unsigned len;
    if (argc < 2 || argc > 3)
     {
        fprintf(stderr,"usage: pack a [b]\n");
        return 1;
     }
    sub1.value = atoi (argv[1]);
    msg.a = &sub1;
    if (argc == 3)
      {
         sub2.value = atoi (argv[2]);
         msg.b = &sub2;
      }
    len = d_message__get_packed_size (&msg);
    buf = malloc (len);
    d_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    return 0;
  } 
}}}
Notice:
  * there is no `has_` flag for optional submessages -- if the pointer is non-NULL, then we assume that it is a value.

TODO: unpack

= Constructing Repeated Submessages =

= Using the Allocator =

= Packing with an Append Function =

= Language Binding Hints =