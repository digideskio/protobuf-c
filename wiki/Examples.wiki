#summary A set of easy examples, in lieu of documentation

= Introduction =

Examples of using [http://www.google.com/codesearch/p?hl=en#Cn85FSbHSs0/trunk/Dependencies/protobuf-2.0.3/src/protobuf-c.c&q=protobuf-c&d=4 protobuf-c].

protobuf-c works by taking a .proto file (which is defined by google's [http://code.google.com/apis/protocolbuffers/ Protocol Buffers] library), and generating both .h and .c files for use in C programs.

PLEASE CONSIDER HELPING:
  * the code should really have lots of comments
  * the examples aren't finished - if you want to write a section, let me know! (send email to lahiker42 AT gmail or post to the discussion group)
  * we need a script to generate a directory of example code from this page (this page will need changing to include the filenames of the scripts in a consistent fashion.

*Warning (insert guy shoveling pic):  this page is partial, incomplete and the code is untested.  Eventually I plan to make an "examples" directory in the .tar.gz so you don't need to cut-n-paste. *

= Simple complete example =


A simple file, `amessage.proto` file following the [http://code.google.com/apis/protocolbuffers/docs/proto.html language guide]:
{{{
   message AMessage
   {
      required int32 a=1; 
      optional int32 b=2;
   }
}}}

Generate .h and .c files from the command-line in your current working directory:
{{{
   protoc-c --c_out=. amessage.proto 
}}}

Serialize/pack the AMessage as follows:
{{{
#include <stdio.h>
#include <stdlib.h>
#include "amessage.pb-c.h"

int main (int argc, const char * argv[]) 
{
    AMessage msg = AMESSAGE__INIT; // AMessage
    void *buf;                     // Buffer to store serialized data
    unsigned len;                  // Length of serialized data
	
    if (argc != 2 && argc != 3)
    {   // Allow one or two integers
        fprintf(stderr,"usage: amessage a [b]\n");
        return 1;
    }
	
    msg.a = atoi(argv[1]);                                   // Put an int in msg
    if (argc == 3) { msg.has_b = 1; msg.b = atoi(argv[2]); } // Add another
    len = amessage__get_packed_size(&msg);                   // This is calculated packing length
	
    buf = malloc(len);        // Allocated memory for packed/encode serialized data
    amessage__pack(&msg,buf); // Put it in buf now
	
    fprintf(stderr,"Writing %d serialized bytes\n",len); // See the length of message
    fwrite(buf,len,1,stdout); // Write to stdout to allow direct command line piping
	
    free(buf); // Free the allocated serialized buffer
    return 0;
}
}}}
I left most error handling out for brevity.  Notice:
  * the use of the {{{A_MESSAGE__INIT}}} macro to construct the message
  * the {{{has_b}}} member corresponds to the optional `b` field -- required fields do not have a {{{has_}}} member.
  * {{{amessage__get_packed_size}}} returns the length of the packed data.
  * {{{a_message__pack}}} serializes the message.

On the other hand, to deserialize/unpack a message, try code like this:
{{{
#include <stdio.h>
#include <stdlib.h>
#include "amessage.pb-c.h"
#define MAX_MSG_SIZE 1024 // 1K

int main (int argc, const char * argv[]) 
{
    AMessage *msg;              // AMessage 
    int i=0;char c;             // Initialize some data holders
    uint8_t buf[MAX_MSG_SIZE];  // Create a temporary buffer
	
    while ((c=fgetc(stdin)) != EOF)
    {
        if (i >= MAX_MSG_SIZE)
        {   // Must handle serialized message size through another wrapper for multiple msgs
            fprintf(stderr,"message too long for allocated buffer\n");
            return 1;
        }
        buf[i++]=c;
    }
		
    msg = amessage__unpack(NULL,i,buf); // Deserialize the serialized data
	
    if (msg == NULL)
    {   // Something failed
        fprintf(stderr,"error unpacking incoming message\n");
        return 1;
    }
	
    printf("Received: a=%d",msg->a);
    if (msg->has_b) // This is the optional data, and set if available
        printf("  b=%d",msg->b);
    printf("\n");
	
    amessage__free_unpacked(msg, NULL);  // Free the unpacked buffer
    return 0;
}
}}}
During linking each above program, make sure include '-lprotobuf -c'

Test by piping one program into the next at command line:
{{{ 
./amessage_serialize 10 2 | ./amessage_deserialize 
Writing: 4 serialized bytes
Received: a=10 b=2
}}}

= Repeated Fields =
Here is a simple file, `cmessage.proto` file:
{{{
   message CMessage
   {
      repeated int c;
   }
}}}

You might write a program to pack a message:
{{{
  #include "cmessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    CMessage msg = C_MESSAGE__INIT;  
   void *buf;
   unsigned len;
   msg.n_c = argc - 1;
   msg.c = malloc (sizeof (int) * msg.n_c);
   for (i = 0; i < msg.n_c; i++)
     msg.c[i] = atoi (argv[i+1]);
    len = c_message__get_packed_size (&msg);
    buf = malloc (len);
    c_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    free (msg.c);
    free (buf);
    return 0;
  } 
}}}
I left most error handling out for brevity.  Notice:
  * the use of the C_MESSAGE__INIT macro to construct the message
  * we allocate buf and msg.c, so we must free them.
  * the n_XXX member is generated for a repeated field XXX.

On the other hand, if you want to deserialize/unpack a message,
you could use code like this:
{{{
  #include "cmessage.pb-c.h"
  #include <stdio.h>
  #define MAX_MESSAGE_SIZE  4096
  int main(int argc, char **argv)
  {
    AMessage *msg;
    char buf[MAX_MESSAGE_SIZE];
    while ((c=fgetc(stdin)) != EOF)
      {
	if (buf_size == MAX_MESSAGE_SIZE)
	  {
	    fprintf(stderr, "message too long for this program\n");
	    return 1;
	  }
	buf[buf_size++] = c;
      }
    msg = c_message__unpack (NULL, buf_size, buf);
    if (msg == NULL)
      {
	fprintf(stderr, "error unpacking message\n");
	return 1;
      }
    for (i = 0; i < msg->n_c; i++)
      {
        if (i > 0)
	  printf (", ");
	printf ("%d", msg->c[i]);
      }
    printf ("\n");
    return 0;
  } 
}}}

= Strings =

= Bytes =


= Constructing Submessages =
Here is a simple file, `dmessage.proto` file:
{{{
   message Submessage
   {
      required int value;
   };
   message DMessage
   {
      required Submessage d;
      optional Submessage e;
   }
}}}

Here is a simple program to pack a message of type `DMessage`.
Note that `DMessage` consists of one or two integers (`d` is required and has one int; `e` is optional and has one int).
  
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    DMessage msg = D_MESSAGE__INIT;  
    Submessage sub1 = SUBMESSAGE__INIT;
    Submessage sub2 = SUBMESSAGE__INIT;
    void *buf;
    unsigned len;
    if (argc < 2 || argc > 3)
     {
        fprintf(stderr,"usage: pack a [b]\n");
        return 1;
     }
    sub1.value = atoi (argv[1]);
    msg.a = &sub1;
    if (argc == 3)
      {
         sub2.value = atoi (argv[2]);
         msg.b = &sub2;
      }
    len = d_message__get_packed_size (&msg);
    buf = malloc (len);
    d_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    return 0;
  } 
}}}
Notice:
  * there is no `has_` flag for optional submessages -- if the pointer is non-NULL, then we assume that it is a value.

TODO: unpack

= Constructing Repeated Submessages =

= Using the Allocator =

= Packing with an Append Function =

= Language Binding Hints =

= Protobuf-C For Embedded Developers (and other cross compilers) =
TODO: move these general comments to a new page and provide an example, as promised by the page title.

Most embedded developers need to compile protobuf-c twice:
  # they need a copy of `protoc-c` that runs on their `build` environment (the `build` environment is for the machine on which they develop the application.
  # they need to have a copy of libprotobuf-c, which is the runtime library, that is compiled for the embedded platform (which we will call the `target` environment).

For (1), you need to install the main protobuf package, since protoc-c uses its parser and code generator libraries.  Running 'configure' as usual should be fine. 

For (2), you can configure with --disable-protoc which means you won't have to build the main protobuf package for the embedded platform (since you don't need to do code gen on the embedded platform).  The usual details of cross-compilation for your specific embedded platform apply.  Sometimes merely providing the name of the platform to configure suffices (as in, `./configure atmel`)-- but other environments need a mass of overrides like `CC=atmel-cc LD=atmel-ld`.

If embedded developers do not modify the `.proto` files, then then all they really need are the generated .pb-c.[ch] files, and then they can skip (1).