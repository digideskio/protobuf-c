#summary A set of easy examples, in lieu of documentation

= Introduction =

Examples of using protobuf-c.

protobuf-c works by taking a .proto file (which is defined by google's Protocol Buffers library), and generating .h and .c files you can use from C.

PLEASE CONSIDER HELPING:
  * the code should really have lots of comments
  * the examples aren't finished - if you want to write a section, let me know!
  * we need a script to generate a directory of example code from this page (this page will need changing to include the filenames of the scripts in a consistent fashion.

*Warning (insert guy shoveling pic):  this page is partial, incomplete and the code is untested.  Eventually I plan to make an "examples" directory in the .tar.gz so you don't need to cut-n-paste. *

= Simple complete example =


Here is a simple file, `amessage.proto` file:
{{{
   message AMessage
   {
      required int a;
      optional int b;
   }
}}}

You can generate .h and .c files from the command-line:
{{{
   protoc-c --output_dir=. FIXME
}}}

You might write a program to pack a message:
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    AMessage msg = A_MESSAGE__INIT;  
   void *buf;
   unsigned len;
   if (argc < 2 || argc > 3)
     {
        fprintf(stderr,"usage: pack a [b]\n");
        return 1;
     }
    msg.a = atoi (argv[1]);
    if (argc == 3) { msg.has_b = 1; msg.b = atoi(argv[2]); }
    len = a_message__get_packed_size (&msg);
    buf = malloc (len);
    a_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    return 0;
  } 
}}}
I left most error handling out for brevity.  Notice:
  * the use of the A_MESSAGE__INIT macro to construct the message
  * the "has_b" member that corresponds to the optional `b` field -- required fields do not have a has_ member.
  * a_message__get_packed_size returns the length of the packed data.
  * a_message__pack serializes the message.

On the other hand, if you want to deserialize/unpack a message,
you could use code like this:
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  #define MAX_MESSAGE_SIZE  4096
  int main(int argc, char **argv)
  {
    AMessage *msg;
    char buf[MAX_MESSAGE_SIZE];
    while ((c=fgetc(stdin)) != EOF)
      {
	if (buf_size == MAX_MESSAGE_SIZE)
	  {
	    fprintf(stderr, "message too long for this program\n");
	    return 1;
	  }
	buf[buf_size++] = c;
      }
    msg = a_message__unpack (NULL, buf_size, buf);
    if (msg == NULL)
      {
	fprintf(stderr, "error unpacking message\n");
	return 1;
      }
    printf ("a=%d", msg->a);
    if (msg->has_b)
      printf ("; b=%d", msg->b);
    printf ("\n");
    return 0;
  } 
}}}

= Repeated Fields =
Here is a simple file, `cmessage.proto` file:
{{{
   message CMessage
   {
      repeated int c;
   }
}}}

You might write a program to pack a message:
{{{
  #include "cmessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    CMessage msg = C_MESSAGE__INIT;  
   void *buf;
   unsigned len;
   msg.n_c = argc - 1;
   msg.c = malloc (sizeof (int) * msg.n_c);
   for (i = 0; i < msg.n_c; i++)
     msg.c[i] = atoi (argv[i+1]);
    len = c_message__get_packed_size (&msg);
    buf = malloc (len);
    c_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    free (msg.c);
    free (buf);
    return 0;
  } 
}}}
I left most error handling out for brevity.  Notice:
  * the use of the C_MESSAGE__INIT macro to construct the message
  * we allocate buf and msg.c, so we must free them.
  * the n_XXX member is generated for a repeated field XXX.

On the other hand, if you want to deserialize/unpack a message,
you could use code like this:
{{{
  #include "cmessage.pb-c.h"
  #include <stdio.h>
  #define MAX_MESSAGE_SIZE  4096
  int main(int argc, char **argv)
  {
    AMessage *msg;
    char buf[MAX_MESSAGE_SIZE];
    while ((c=fgetc(stdin)) != EOF)
      {
	if (buf_size == MAX_MESSAGE_SIZE)
	  {
	    fprintf(stderr, "message too long for this program\n");
	    return 1;
	  }
	buf[buf_size++] = c;
      }
    msg = c_message__unpack (NULL, buf_size, buf);
    if (msg == NULL)
      {
	fprintf(stderr, "error unpacking message\n");
	return 1;
      }
    for (i = 0; i < msg->n_c; i++)
      {
        if (i > 0)
	  printf (", ");
	printf ("%d", msg->c[i]);
      }
    printf ("\n");
    return 0;
  } 
}}}

= Strings =

= Bytes =


= Constructing Submessages =
Here is a simple file, `dmessage.proto` file:
{{{
   message Submessage
   {
      required int value;
   };
   message DMessage
   {
      required Submessage d;
      optional Submessage e;
   }
}}}

Here is a simple program to pack a message of type `DMessage`.
Note that `DMessage` consists of one or two integers (`d` is required and has one int; `e` is optional and has one int).
  
{{{
  #include "amessage.pb-c.h"
  #include <stdio.h>
  int main(int argc, char **argv)
  {
    DMessage msg = D_MESSAGE__INIT;  
    Submessage sub1 = SUBMESSAGE__INIT;
    Submessage sub2 = SUBMESSAGE__INIT;
    void *buf;
    unsigned len;
    if (argc < 2 || argc > 3)
     {
        fprintf(stderr,"usage: pack a [b]\n");
        return 1;
     }
    sub1.value = atoi (argv[1]);
    msg.a = &sub1;
    if (argc == 3)
      {
         sub2.value = atoi (argv[2]);
         msg.b = &sub2;
      }
    len = d_message__get_packed_size (&msg);
    buf = malloc (len);
    d_message__pack (&msg, buf);
    fwrite (buf, len, 1, stdout);
    return 0;
  } 
}}}
Notice:
  * there is no `has_` flag for optional submessages -- if the pointer is non-NULL, then we assume that it is a value.

TODO: unpack

= Constructing Repeated Submessages =

= Using the Allocator =

= Packing with an Append Function =

= Language Binding Hints =

= Protobuf-C For Embedded Developers (and other cross compilers) =
Most embedded developers need to compile protobuf-c twice:
  # they need a copy of protoc-c that runs on their `build` environment.
  # they need to have a copy of libprotobuf-c, which is the runtime, that is 
compiled for the embedded platform (which we will call the `target` environment.

For (1), you need to install the main protobuf package, since protoc-c uses 
its parser and code generator libraries.  Running 'configure' as usual 
should be fine. 

For (2), you can configure with --disable-protoc which means you won't have 
to build the main protobuf package for the embedded platform (since you 
don't need to do code gen on the embedded platform).  They presumably are 
used to cross-compiling, so they can probably figure out that aspect. 

If embedded developers do not modify the `.proto` files, then then all they really need are the generated .pb-c.[ch] files, and then they can skip (1).