#summary Protocol-Buffer Service C Mapping

= Introduction =

Protocol-Buffers defines a mapping for a Service, which boils down to list of methods, each having:
  * a name
  * an input message type
  * an output message type

The C binding protobuf-c defines a C structure, ProtobufCService, which is the basis for both
  * services generated by protoc-c (the protobuf C code generator)
  * services implemented by RPC systems (protobuf-c-rpc is an example)

When using the code generator, the service is "derived" from ProtobufCService like this (this is from the output of `protoc-c`):
 
{{{ 
 typedef struct _Foo__DirLookup_Service Foo__DirLookup_Service;
 struct _Foo__DirLookup_Service
 {
  ProtobufCService base;
  void (*by_name)(Foo__DirLookup_Service *service,
                  const Foo__Name *input,
                  Foo__LookupResult_Closure closure,
                  void *closure_data);
 };
}}}
We generate two macros:
   * `FOO__DIR_LOOKUP__BASE_INIT` which defines merely the functions for `base`.  It looks like:
{{{
#define FOO__DIR_LOOKUP__BASE_INIT \
    { &foo__dir_lookup__descriptor, protobuf_c_service_invoke_internal, NULL }
}}}
   * `FOO__DIR_LOOKUP__INIT(function_prefix__)` which assumes that all the methods required by this service are `function_prefix__` followed by the method name.  It looks like:
{{{
#define FOO__DIR_LOOKUP__INIT(function_prefix__) \
    { FOO__DIR_LOOKUP__BASE_INIT,\
      function_prefix__ ## by_name  }
}}}

= RPC Implementations =
RPC Implementation take advantage of the fact that all methods are marshalled through the `invoke` method of `ProtobufCService`:
{{{
struct _ProtobufCService
{
  const ProtobufCServiceDescriptor *descriptor;
  void (*invoke)(ProtobufCService *service,
                 unsigned          method_index,
                 const ProtobufCMessage *input,
                 ProtobufCClosure  closure,
                 void             *closure_data);
  void (*destroy) (ProtobufCService *service);
};
}}}
The generated code's invoke function is always the same:  invoke the function at `method_index`, assuming the list of methods directly follows the `ProtobufCService`.  This function is implemented in `protobuf-c.c`:
{{{
void
protobuf_c_service_invoke_internal(ProtobufCService *service,
                                  unsigned          method_index,
                                  const ProtobufCMessage *input,
                                  ProtobufCClosure  closure,
                                  void             *closure_data)
{
  GenericHandler *handlers;
  GenericHandler handler;

  /* Verify that method_index is within range.
     If this fails, you are likely invoking a newly added
     method on an old service.  (Although other memory corruption
     bugs can cause this assertion too) */
  PROTOBUF_C_ASSERT (method_index < service->descriptor->n_methods);

  /* Get the array of virtual methods (which are enumerated by 
     the generated code) */
  handlers = (GenericHandler *) (service + 1);

  /* get our method and invoke it */
  /* TODO: seems like handler==NULL is a situation that
     needs handling */
  handler = handlers[method_index];
  (*handler) (service, input, closure, closure_data);
}
}}}
(look at how that will do the right thing with `Foo__DirLookup_Service` above)

= Destruction =
The macros assume you don't need a destructor for this service.  That may be naive... so you must set the `destroy` function of `ProtobufCService`  before supplying the `ProtobufCService` to naive code that expects `destroy` to be adequate (or NULL to do nothing).