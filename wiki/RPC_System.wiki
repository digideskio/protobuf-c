#summary The RPC system provided by protobuf-c
= TODO =
things to do before release:
  * function (prototyped) to allow client to block for connect
  * implement protobuf_c_rpc_client_connect()
  * example
  * more extensive test code

= Introduction =

Protocol buffers provides a mechanism for defining a "service", which is intended to form the basis for an "remote-procedure call" (RPC) system.  They do not actually provide any implementation or protocol suggestions for doing so, both in the name of generality, and because google's internal protocols are tied to their architecture too strongly [cite?].

protobuf-c, by constrast _does_ provide an implementation.  We will first describe the protocol, and then give an API for using it.

= Operational Summary of the RPC Implementation ==
Remember that a *service* in protocol-buffers are an array of named methods, each of which takes a single message input and provides a single message output; the input and output types are specified in the .proto file.

Our RPC system adds some more ideas:
  * the *client* is the active end of the tcp or unix-domain socket connection.  Once connected, it can invoke functions on the server.  The client object we provide implements automatic reconnection if the server is down.
  * the *server* is the passive end of the tcp or unix-domain connection.  It has an underlying ProtobufCService that it will call at the behest of the clients.  As usual, many clients may be connected to a single server.
  * the *dispatch* is a way of handling multiple connections from a single thread.  We use it for the client and the server.  The idea is the same as a "main-loop": we accept requests for which file-descriptors to watch for which events.  We chose to call it a "dispatch" because it is designed to be embedded in the main loops of applications, although it can also run standalone.

= The Encapsulation Protocol =
We here describe the way to pass messages across the socket; the translation of the messages themselves into bytes is done by core protobuf, but it leaves several unspecified parts:
  * how should the client specify which method to invoke?
  * how should the client and server specify the protobuf-encoded message-length? (It cannot be determined by examining the bytes.)
  * how should failures be passed back to the client?
  * if the protocol allows pipelining, how should we support out-of-order responses? (i.e. how does the client match the server's response to its request?)

Our encapsulation protocol is designed to facilitate pipelining of requests.  It can be much more efficient to pipeline many small requests.

The client issues a 12 byte header followed by the protobuf-encoded message payload:
  * method index (encoded as a 4-byte little-endian number)
  * message length: the length of the protobuf-encoded payload (encoded 4-byte little-endian)
  * request id: a value chosen by the client to allow it to know which server response corresponds to which request, in the case of multiple outstanding requests). (encoded in 4 bytes)

The server eventually issues a similar 16 byte response:
  * status code (as a 4-byte little-endian number).  One of the following values:
    * 0: success
    * 1: service failed (ie passed in NULL for the message to the closure)
    * 2: too many pending (client connection has too many pending requests)
  * method index (same as for request)
  * message length (same as for request)
  * request id (same as for request)

= Programmer's Reference (API Documentation) =
The basic gist is:
{{{
   Service *create_client (Location, ServiceDescriptor)
   void     create_server (Port, Service);
}}}
So you see:
  * the client connects to the Location and using the message formats given by the ServiceDescriptor.
  * the server binds to the Port and answers requests using the Service.

Of course, as usual, C naming conventions are never that short.  Here's the
real functions:

{{{
ProtobufCService     *protobuf_c_rpc_client_new (ProtobufC_RPC_AddressType  type,
                                                 const char                *name,
                                                 const ProtobufCServiceDescriptor *descriptor,
                                                 ProtobufCDispatch         *dispatch);
ProtobufC_RPC_Server *protobuf_c_rpc_server_new (ProtobufC_RPC_AddressType  type,
                                                 const char                *name,
                                                 ProtobufCService          *service,
                                                 ProtobufCDispatch         *dispatch);
}}}
We return a ProtobufC_RPC_Server object to allow for additional configuration
and monitoring of the server.

The [RPC_API] page has more details.

== API Details: Constructing a Client ==
{{{
typedef enum
{
  PROTOBUF_C_RPC_ADDRESS_LOCAL,  /* unix-domain socket */
  PROTOBUF_C_RPC_ADDRESS_TCP     /* host/port tcp socket */
} ProtobufC_RPC_AddressType;

ProtobufCService *protobuf_c_rpc_client_new (ProtobufC_RPC_AddressType type,
                                             const char               *name,
                                             const ProtobufCServiceDescriptor *descriptor,
                                             ProtobufCDispatch       *dispatch);
}}}
Create a new connection to a protobuf-c-rpc server.  _type_ and _name_ 
give the location of the server.
  * if _type_ is PROTOBUF_C_RPC_ADDRESS_LOCAL then the _name_ is a path in the local filesystem
  * if _type_ is PROTOBUF_C_RPC_ADDRESS_TCP then the _name_ is a host:port combination.

The _descriptor_ gives the service format data (e.g. which methods exist and their types).

The _dispatch_ is the main-loop with which 
to register file-descriptors and timeouts.  If given NULL if
will use the default dispatch.

The client does not block until it is connected.
Sometimes you want to do just that:
{{{
typedef enum
{
  PROTOBUF_C_RPC_CLIENT_CONNECT_SUCCESS,
  PROTOBUF_C_RPC_CLIENT_CONNECT_ERROR_NAME_LOOKUP,
  PROTOBUF_C_RPC_CLIENT_CONNECT_ERROR_CONNECT
} ProtobufC_RPC_Client_ConnectStatus;
ProtobufC_RPC_Client_ConnectStatus
protobuf_c_rpc_client_connect (ProtobufC_RPC_Client *client);
}}}

== API Details:  Configuring the Client ==
{{{
void protobuf_c_rpc_client_set_name_resolver (ProtobufC_RPC_Client *client,
                                              ProtobufC_NameLookup_Func resolver);
}}}
This is an API to allow you to plug in a different name-resolver.  In particular an asynchronous DNS
implementation would be really nice.  Anybody want to contribute one that I can
put in the distro?

{{{
typedef void (*ProtobufC_RPC_Error_Func)   (ProtobufC_RPC_Error_Code code,
                                            const char              *message,
                                            void                    *error_func_data);

void protobuf_c_rpc_client_set_error_handler (ProtobufC_RPC_Client *client,
                                              ProtobufC_RPC_Error_Func func,
                                              void                 *error_func_data);
}}}
Set a function that will be called whenever an error occurs with the client.

{{{
void protobuf_c_rpc_client_disable_autoretry (ProtobufC_RPC_Client *client);
void protobuf_c_rpc_client_set_autoretry_period (ProtobufC_RPC_Client *client,
                                                 unsigned              millis);
}}}
These functions can be used to configure whether the client
will automatically try to connect again if it is disconnected.  The default is to try
reconnecting rather frequently.

{{{
protobuf_c_boolean protobuf_c_rpc_client_is_connected (ProtobufC_RPC_Client *client);
}}}
Return TRUE if the client is connected to the server.  If the client is not connected,
all requests to the client will fail immediately.

== API Details: Constructing a Server ==

{{{
ProtobufC_RPC_Server *
     protobuf_c_rpc_server_new        (ProtobufC_RPC_AddressType type,
                                       const char               *name,
                                       ProtobufCService         *service,
                                       ProtobufCDispatch       *dispatch);
}}}

== API Details:  Configuring the Server ==
{{{
void protobuf_c_rpc_server_disable_autotimeout(ProtobufC_RPC_Server *server);
void protobuf_c_rpc_server_set_autotimeout (ProtobufC_RPC_Server *server,
                                            unsigned              timeout_millis);
}}}
unimplemented.  disconnect a client that has been idle too long.

{{{
void protobuf_c_rpc_server_set_error_handler (ProtobufC_RPC_Server *server,
                                              ProtobufC_RPC_Error_Func func,
                                              void                 *error_func_data);
}}}
Register a function to call if an error occurs.

== API Details:  Cleaning up ==
{{{
void protobuf_c_service_destroy       (ProtobufCService         *client);
ProtobufCService *
     protobuf_c_rpc_server_destroy    (ProtobufC_RPC_Server     *server,
                                       protobuf_c_boolean        free_underlying_service);
}}}

== API Details: the Dispatch ==