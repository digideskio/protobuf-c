#summary The RPC system provided by protobuf-c
= Introduction =

Protocol buffers provides a mechanism for defining a "service", which is intended to form the basis for an "remote-procedure call" (RPC) system.  They do not actually provide any implementation or protocol suggestions for doing so, both in the name of generality, and because google's internal protocols are tied to their architecture too strongly [cite?].

protobuf-c, by constrast _does_ provide an implementation.  We will first describe the protocol, and then give an API for using it.

= The Protocol =
The protocol is designed to facilitate pipelining of requests.
The client issues a 12 byte header followed by the protobuf-encoded message payload:
  * method index (encoded as a 4-byte little-endian number)
  * message length: the length of the protobuf-encoded payload (encoded 4-byte little-endian)
  * request id: a value chosen by the client to allow it to know which server response corresponds to which request, in the case of multiple outstanding requests). (encoded in 4 bytes)

The server eventually issues a similar 16 byte response:
  * status code (as a 4-byte little-endian number).  One of the following values:
    * 0: success
    * 1: service failed (ie passed in NULL for the message to the closure)
    * 2: too many pending (client connection has too many pending requests)
  * method index (same as for request)
  * message length (same as for request)
  * request id (same as for request)

= Operational Summary of the RPC Implementation ==
Remember that a *service* in protocol-buffers as an array of named methods, each of which takes a single message input and provides a single message output; the input and output types are specified in the .proto file.

Our RPC system adds some more ideas:
  * the *client* is the active end of the tcp or unix-domain socket connection.  Once connected, it can invoke functions on the server.  The client object we provide implements automatic reconnection if the server is down.
  * the *server* is the passive end of the tcp or unix-domain connection.  It has an underlying ProtobufCService that it will call at the behest of the clients.  As usual, many clients may be connected to a single server.
  * the *dispatch* is a way of handling multiple connections from a single thread.  We use it for the client and the server.  The idea is the same as a "main-loop": we accept requests for which file-descriptors to watch for which events.  We chose to call it a "dispatch" because it is designed to be embedded in the main loops of applications, although it can also run standalone.

= API =
{{{
typedef enum
{
  PROTOBUF_C_RPC_ADDRESS_LOCAL,  /* unix-domain socket */
  PROTOBUF_C_RPC_ADDRESS_TCP     /* host/port tcp socket */
} ProtobufC_RPC_AddressType;

ProtobufCService *protobuf_c_rpc_client_new (ProtobufC_RPC_AddressType type,
                                             const char               *name,
                                             const ProtobufCServiceDescriptor *descriptor,
                                             ProtobufCDispatch       *dispatch);
ProtobufC_RPC_Server *
     protobuf_c_rpc_server_new        (ProtobufC_RPC_AddressType type,
                                       const char               *name,
                                       ProtobufCService         *service,
                                       ProtobufCDispatch       *dispatch);
}}}

== API Details:  Configuring the Client ==
== API Details:  Configuring the Server ==
== API Details:  Cleaning up ==
{{{
void protobuf_c_service_destroy       (ProtobufCService         *client);
ProtobufCService *
     protobuf_c_rpc_server_destroy    (ProtobufC_RPC_Server     *server,
                                       protobuf_c_boolean        free_underlying_service);
}}}

== API Details: the Dispatch ==