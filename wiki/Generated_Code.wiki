= The Generated Code =
For each enum, we generate a C enum.
For each message, we generate a C structure
which can be cast to a `ProtobufCMessage`.

For each enum and message, we generate a descriptor
object that allows us to implement a kind of reflection
on the structures.

= Naming and Casing Conventions =

  * The name of the type for enums and messages and services is camel case (meaning !WordsAreCrammedTogether) except that double-underscores are used to delimit scopes.  For example:
{{{
                package foo.bar;
                message BazBah {
                  required int32 val;
                  optional string val2;
                }
}}}
  would generate a C type `Foo__Bar__BazBah`.

  * Functions and globals are all lowercase, with camel-case words separated by single underscores.  For example:
{{{
           Foo__Bar__BazBah *foo__bar__baz_bah__unpack
                                 (ProtobufCAllocator  *allocator,
                                  size_t length,
                                  const uint8_t *data);
}}}
  * Enums values are all uppercase.
  * Stuff we add to your symbol names will also be separated by a double-underscore.  For example, the unpack method above.

= Descriptors =

We also generate descriptor objects for messages and enums.
These are declared in the .h files:
{{{
   extern const ProtobufCMessageDescriptor
                     foo__bar__baz_bah__descriptor;
}}}

For the definitions of the various `Descriptor` structures,
see the [libprotobuf_c] page.

= Message Methods =

To initialize a message for yourself,
`memset` it with 0 and set the `descriptor` member.
For example:
{{{
    Foo__Bar__BazBah message;
    memset (&message, 0, sizeof (message));
    message.base.descriptor = &foo__bar__baz_bah__descriptor;
}}}
The `descriptor` field is very important:
that's what allows the library to act on the message generically.

Another way to initialize a message is to use the generated static initializer macro:
{{{
    Foo__Bar__BazBah message = FOO__BAR__BAZ_BAH__INIT;
}}}
This will initialize any defaults that do not require allocation.

You might prefer to use the static initializer we provide.  It obeys many default values (but it doesn't handle default values that would require allocations).  To do that:
{{{
    Foo__Bar__BazBah message = FOO__BAR__BAZ_BAH__INIT;
}}}

We generate some functions for each message:
  * `unpack()`.  Unpack data for a particular message-format, using an optional allocator for the data:
{{{
     Foo__Bar__BazBah *
     foo__bar__baz_bah__unpack  (ProtobufCAllocator *allocator,
                                 size_t length,
                                 const unsigned char *data);
}}}
    It's a good idea to not modify the unpacked message.  That's because we haven't decided exactly whether the message's fields are allocated separately or together.  The only thing you can really assume is that free_unpacked() will always to the right thing with the return value from unpack().
    In practice, we will never be allocating memory for required and optional primitive types, so you CAN modify those values before calling free_unpacked().

    To make other kinds of changes, make a copy and track your own allocations:
{{{
    Foo__Bar__BazBah *unpacked;
    Foo__Bar__BazBah my_bazbah;
    unpacked = foo__bar__baz_bah__unpack (NULL, len, data);
    my_bazbah = *unpacked;
    my_bazbah.val2 = "my string";
    ... when done with unpacked and my_bazbah, call free_unpacked()
}}}
  * `free_unpacked()`.  Free a message that you obtained with the unpack method:
{{{
     void
     foo__bar__baz_bah__free_unpacked  (Foo__Bar__BazBah *baz_bah,
                                        ProtobufCAllocator *allocator);
}}}
  * `get_packed_size()`.  Find how long the serialized representation of the data will be:
{{{
     size_t
     foo__bar__baz_bah__get_packed_size 
                        (const Foo__Bar__BazBah *message);
}}}
  * `pack()`.  Pack message into buffer; assumes that buffer is long enough (use get_packed_size first!).
{{{
     size_t
     foo__bar__baz_bah__pack
                        (const Foo__Bar__BazBah *message,
                         unsigned char *packed_data_out);
}}}
  * `pack_to_buffer()`.  Pack message into virtualized buffer.
{{{
     size_t
     foo__bar__baz_bah__pack_to_buffer
                        (const Foo__Bar__BazBah *message,
                         ProtobufCBuffer *buffer);
}}}

For the definitions of `ProtobufCBuffer` and `ProtobufCAllocator`,
see the [libprotobuf_c] page.

== Services ==
Services are collections of methods each having an input and output type.
Unlike messages where we generate a structure that corresponds
to the actual message object, for services we generate
a function that creates a `ProtobufCService`
from a collection of user-defined methods.

We also define simple functions that invoke each method of a service.
These functions work if the service is created by
the `create_service` generated function
or if the service is instantiated by an RPC system.

Suppose we have a .proto file:
{{{
     message A {
       required uint32 val;
     }
     message B {
       required string foo;
     }
     service Convert {
       rpc Itoa (A) returns (B);
       rpc Atoi (B) returns (A);
     }
}}}

We will get generated code:
{{{
    struct _Convert_Service {
      ProtobufCService base;

      void (*itoa) (Convert_Service *service,
                    const A *input,
                    B__Closure closure,
                    void *closure_data);
      void (*atoi) (Convert_Service *service,
                    const B *input,
                    A__Closure closure,
                    void *closure_data);
      void (*destroy) (Convert_Service *service);
    };
}}}

XXX: the following is totally wrong... but it is a nice example to exposit on, so we preserve it for editing convenience... be wary...

Note that `create_service` takes ownership of `service`.
For example, here's how to implement a convert service that takes the default radix to use:
{{{
      /* structure derived from Convert_Service. */
      typedef struct {
        Convert_Service base;   /* must be first member */
        unsigned radix;
      } Convert_WithRadix;

      /* convert int to string (not really implemented) */
      static void radix_itoa (Convert_Service *service,
                              const A *input,
                              B__Closure closure,
                              void *closure_data)
      {
        char buf[256];
        Convert_WithRadix *wr = (Convert_WithRadix *) service;
        B rv;
        print_int_with_radix (input->val, wr->radix, buf);
        rv.descriptor = &b__descriptor;
        rv.str = buf;
        closure (&rv, closure_data);
      }

      /* convert string to int: use strtoul */
      static void radix_atoi (Convert_Service *service,
                              const B *input,
                              A__Closure closure,
                              void *closure_data)
      {
        Convert_WithRadix *wr = (Convert_WithRadix *) service;
        A rv;
        rv.val = strtoul (input->val, NULL, wr->radix);
        rv.descriptor = &a__descriptor;
        closure (&rv, closure_data);
      }

      /* create a new convert service by radix */
      ProtobufCService *
      create_convert_service_from_radix (unsigned radix)
      {
        Convert_WithRadix *wr = malloc (sizeof (Convert_WithRadix));
        ... TODO: init function ...
        wr->base.itoa = radix_itoa;
        wr->base.atoi = radix_atoi;
        wr->base.destroy = (void(*)(Convert_Service *)) free;
        wr->radix = radix;
        return &wr->base;
      }
}}}

You can cast your service to a `ProtobufCService` object.

Conversely, we generate functions to help you invoke service
methods on generic `ProtobufCService` objects.
These go through the `invoke()` of service
and they work on both services created with create_service
as well as factory-provided services like those provided by RPC systems.
For example:
{{{
       void convert__itoa (ProtobufCService *service,
                           const B *input,
                           A__Closure closure,
                           void *closure_data);
}}}