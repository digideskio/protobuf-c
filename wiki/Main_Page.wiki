#summary protobuf-c wiki home page

= Introduction =

protobuf-c is a C binding for Google's Protocol Buffers (aka protobuf) library and code generator.

The overall [[design]] is similar to the C++ structure,
except we try to generate as little code as possible.

To use the system, you should read more
about [[Generated Code|the code we generate]].
To understand how the generated code works,
read about [[libprotobuf-c]].
 <section>
  <title>The protobuf-c Library</title>

<para>This library is used by the generated code;
it includes common structures and enums,
as well as functions that most users of the generated code
will want.</para>

<para>
There are three main components:
 <orderedlist>
  <listitem><para>the Descriptor structures</para></listitem>
  <listitem><para>helper structures and objects</para></listitem>
  <listitem><para>packing and unpacking code</para></listitem>
 </orderedlist>
</para>

 </section>
 <section>
  <title>protobuf-c:  the Descriptor structures</title>

<para>For example, enums are described in terms of structures:

<programlisting><![CDATA[
    struct _ProtobufCEnumValue
    {
      const char *name;
      const char *c_name;
      int value;
    };

    struct _ProtobufCEnumDescriptor
    {
      const char *name;
      const char *short_name;
      const char *package_name;

      /* sorted by value */
      unsigned n_values;
      const ProtobufCEnumValue *values;

      /* sorted by name */
      unsigned n_value_names;
      const ProtobufCEnumValue *values_by_name;
    };
]]></programlisting></para>

<para>Likewise, messages are described by:

<programlisting><![CDATA[
      struct _ProtobufCFieldDescriptor
      {
        const char *name;
        int id;
        ProtobufCFieldLabel label;
        ProtobufCFieldType type;
        unsigned quantifier_offset;
        unsigned offset;
        void *descriptor;       /* for MESSAGE and ENUM types */
      };
      struct _ProtobufCMessageDescriptor
      {
        const char *name;
        const char *short_name;
        const char *package_name;

        /* sorted by field-id */
        unsigned n_fields;
        const ProtobufCFieldDescriptor *fields;
      };
]]></programlisting></para>

<para>
And finally services are described by:

<programlisting><![CDATA[
      struct _ProtobufCMethodDescriptor
      {
        const char *name;
        const ProtobufCMessageDescriptor *input;
        const ProtobufCMessageDescriptor *output;
      };
      struct _ProtobufCServiceDescriptor
      {
        const char *name;
        unsigned n_methods;
        ProtobufCMethodDescriptor *methods;             // sorted by name
      };
]]></programlisting></para>

 </section>
 <section>
  <title>protobuf-c:  helper structures and typedefs</title>

<para>We defined typedefs for a few types
which are used in .proto files but do not
have obvious standard C equivalents:
<itemizedlist>
<listitem><para>a boolean type (<type>protobuf_c_boolean</type>)</para></listitem>
<listitem><para>a binary-data (bytes) type (<type>ProtobufCBinaryData</type>)</para></listitem>
<listitem><para>the various int types (<type>int32_t</type>, <type>uint32_t</type>, <type>int64_t</type>, <type>uint64_t</type>)
are obtained by including <filename>inttypes.h</filename></para></listitem>
</itemizedlist>
</para>

<para>We also define a simple allocator object, ProtobufCAllocator
that let's you control how allocations are done.
This is predominately used for parsing.</para>

<para>There is a virtual buffer facility that 
only has to implement a method to append binary-data
to the buffer.  This can be used to serialize messages
to different targets (instead of a flat slab of data).</para>

<para>We define a base-type for all messages,
for code that handles messages generically.
All it has is the descriptor object.</para>

<section id="buffers">  
 <title>Buffers</title>
 <para>One important helper type is the <type>ProtobufCBuffer</type>
 which allows you to abstract the target of serialization.  The only
 thing that a buffer has is an <function>append</function> method:
<programlisting><![CDATA[
   struct _ProtobufCBuffer
   {
     void (*append)(ProtobufCBuffer     *buffer,
                    size_t               len,
                    const unsigned char *data);
   }
]]></programlisting>
  ProtobufCBuffer subclasses are often defined on the stack.
</para>

<para>
For example, to write to a <type>FILE</type> you could make:
<programlisting><![CDATA[
   typedef struct
   {
     ProtobufCBuffer base;
     FILE *fp;
   } BufferAppendToFile
   static void my_buffer_file_append (ProtobufCBuffer   *buffer,
                               unsigned         len,
                               const unsigned char *data)
   {
     BufferAppendToFile *file_buf = (BufferAppendToFile *) buffer;
     fwrite (data, len, 1, file_buf->fp);  // XXX: no error handling!
   }
]]></programlisting>
</para>

<para>
To use this new type of Buffer, you would do something like:
<programlisting><![CDATA[
     ...
     BufferAppendToFile tmp;
     tmp.base.append = my_buffer_file_append;
     tmp.fp = fp;
     protobuf_c_message_pack_to_buffer (&message, &tmp);
     ...
]]></programlisting>
</para>
<para>
  A commonly builtin subtype is the BufferSimple
  which is declared on the stack and uses a scratch buffer provided by the user
  for its initial allocation.  It does exponential resizing.
  To create a BufferSimple, use code like:
  <programlisting><![CDATA[
    unsigned char pad[128];
    ProtobufCBufferSimple buf = PROTOBUF_C_BUFFER_SIMPLE_INIT (pad);
    ProtobufCBuffer *buffer = (ProtobufCBuffer *) &simple;
    protobuf_c_buffer_append (buffer, 6, (unsigned char *) "hi mom");
  ]]></programlisting>
  You can access the data as buf.len and buf.data. For example,
  <programlisting><![CDATA[
   assert (buf.len == 6);
   assert (memcmp (buf.data, "hi mom", 6) == 0);
 ]]></programlisting>
  To finish up, use:
  <programlisting><![CDATA[
    PROTOBUF_C_BUFFER_SIMPLE_CLEAR (&buf);
  ]]></programlisting>
 </para>
 </section>
 </section>
 <section>
  <title>protobuf-c: packing and unpacking messages</title>

<para>
To pack messages one first computes their packed size,
then provide a buffer to pack into.  
<programlisting><![CDATA[
    size_t protobuf_c_message_get_packed_size
                                     (ProtobufCMessage *message);
    void   protobuf_c_message_pack   (ProtobufCMessage *message,
                                      unsigned char    *out);
]]></programlisting>
</para>

<para>
Or you can use the "streaming" approach:
<programlisting><![CDATA[
    void   protobuf_c_message_pack_to_buffer
                                     (ProtobufCMessage *message,
                                      ProtobufCBuffer  *buffer);
]]></programlisting>
where <type>ProtobufCBuffer</type> is a base object with an append metod.
See <xref linkend="buffers" />.
</para>



<para>
To unpack messages, you should simple call
<programlisting><![CDATA[
      ProtobufCMessage *
         protobuf_c_message_unpack (const ProtobufCMessageDescriptor *,
                                    ProtobufCAllocator  *allocator,
				    size_t               len,
				    const unsigned char *data);
]]></programlisting>
If you pass NULL for <parameter>allocator</parameter>, then
the default allocator will be used.
</para>

<para>
You can cast the result to the type that matches
the descriptor.
</para>

<para>
The result of unpacking should be freed with protobuf_c_message_free().
</para>


 </section>
 <section>
  <title>Author</title>
    <para>Dave Benson.</para>
 </section>
</article>
